\documentclass[hyperref={pdfpagelabels=false}]{beamer}
% ATTENTION : modifier /usr/share/texmf/web2c/texmf.cnf : chercher la ligne qui commence par main_memory (sans %) et mettre la valeur 30000000
% hyperref and lmodern : http://texblog.net/latex-archive/presentations/beamer-warnings/
\usepackage{lmodern}
\renewcommand\mathfamilydefault{\rmdefault}
% \usepackage[utf8]{inputenc}
% \DeclareUnicodeCharacter{B0}{\textdegree}% °
% \DeclareUnicodeCharacter{2264}{\leq}% ≤
% \DeclareUnicodeCharacter{2265}{\geq}% ≥
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage{hyperref}
% pgf 2.10 sous ubuntu :
% https://launchpad.net/ubuntu/precise/i386/pgf/2.10-1
% http://launchpadlibrarian.net/70800349/pgf_2.10-1_all.deb
\usepackage{tikz}
\usetikzlibrary{positioning,calc,chains}
\usetheme{Frankfurt}
\usepackage{graphicx}

\title{FMIN313 Moteurs de jeux\\ Génération de terrains}
\author{DUPÉRON Georges \and\texorpdfstring{\\}{} BONAVERO Yoann}
\institute{Université Montpellier II,\\Département informatique\\Master 2 IFPRU\\Encadrants~: F. Koriche et M. Moulis}
\date{Lundi 14 novembre 2011}

\defbeamertemplate*{footline}{shadow theme}
{%
  \leavevmode%
  \hbox{\begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm plus1fil,rightskip=.3cm]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertframenumber\,/\,\inserttotalframenumber%\hfill\url{http://www.pticlic.fr/}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm,rightskip=.3cm plus1fil]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle%
  \end{beamercolorbox}}%
  \vskip0pt%
}

\AtBeginSection[] {
  \begin{frame}
    \frametitle{Plan}
    \tableofcontents[currentsection]
  \end{frame}
  \addtocounter{framenumber}{-1}
}

\begin{document}
\makeatletter\renewcommand*{\figurename}{\@gobble}\makeatother

\begin{frame}
  \titlepage
\end{frame}

% \section{Introduction}

\section{Génération}

\pgfmathrnd
\xdef\noiseseed{\pgfmathresult}

\makeatletter
\def\getcache#1{\csname cache,#1\endcsname}
\def\setcache#1#2{\expandafter\xdef\csname cache,#1\endcsname{#2}}
\def\clearcache#1{\expandafter\global\expandafter\let\csname cache,#1\endcsname\@undefined}
\def\setintmacro#1#2{\pgfmathparse{int(#2)}\edef#1{\pgfmathresult}}
%
\pgfmathdeclarefunction{lazyifthenelse}{3}{%
  \ifx 1#1%
  \pgfmathparse{#2}%
  \else%
  \pgfmathparse{#3}%
  \fi%
}
\makeatother

\shorthandoff{;?:}
\tikzset{
  declare function={
    hash_3(\a,\b)=Mod(\a*\a+\b,1);
    hash_2(\a,\b)=hash_3(mod(\a*\b,1.783)+77.123,mod(\a+\b,1.843)*-0.179);
    hash(\a,\b)=hash_2(mod(\a+\b,1.783)*0.417,mod(\a*\b,1.843)+42.56);
    noise1D(\x,\octave)=hash(\x,hash(\octave,\noiseseed));
    sampleLeft(\x,\periode,\octave)=noise1D(floor(\x/\periode), \octave);
    sampleLeftLeft(\x,\periode,\octave)=noise1D(floor(\x/\periode)-1, \octave);
    sampleRight(\x,\periode,\octave)=noise1D(floor(\x/\periode)+1, \octave);
    sampleRightRight(\x,\periode,\octave)=noise1D(floor(\x/\periode)+2, \octave);
    sampleDelta(\x,\periode)=frac(\x/\periode);
    linearInterpolation(\x,\a,\b)=\x*(\b-\a) + \a;
    cosineInterpolation(\x,\a,\b)=(1-cos(\x*180))*0.5*(\b-\a) + \a;
    cubicInterpolation_(\x,\p,\q,\r,\s)=((\p*\x + \q)*\x + \r)*\x + \s;
    cubicInterpolation(\x,\a,\b,\c,\d)=cubicInterpolation_(\x, (\d-\c)-(\a-\b), ((\a-\b)*2)-(\d-\c), \c-\a, \b);
    % Using linear interpolation
    octave1DLinear(\x,\octave,\periode,\amplitude)=\amplitude*linearInterpolation(sampleDelta(\x,\periode), sampleLeft(\x,\periode,\octave), sampleRight(\x,\periode,\octave));
    perlin1DLinear_(\x,\octave,\periode,\octaves,\persistance,\amplitude)=lazyifthenelse(\octave >= \octaves, 0, "octave1DLinear(\x,\octave,\periode,\amplitude) + perlin1DLinear_(\x,\octave+1,\periode*0.5,\octaves,\persistance,\amplitude*\persistance)");
    perlin1DLinear(\x,\periode,\octaves,\persistance,\amplitude)=perlin1DLinear_(\x,0,\periode,\octaves,\persistance,\amplitude);
    % Using cosine interpolation
    octave1DCosine(\x,\octave,\periode,\amplitude)=\amplitude*cosineInterpolation(sampleDelta(\x,\periode), sampleLeft(\x,\periode,\octave), sampleRight(\x,\periode,\octave));
    perlin1DCosine_(\x,\octave,\periode,\octaves,\persistance,\amplitude)=lazyifthenelse(\octave >= \octaves, 0, "octave1DCosine(\x,\octave,\periode,\amplitude) + perlin1DCosine_(\x,\octave+1,\periode*0.5,\octaves,\persistance,\amplitude*\persistance)");
    perlin1DCosine(\x,\periode,\octaves,\persistance,\amplitude)=perlin1DCosine_(\x,0,\periode,\octaves,\persistance,\amplitude);
    % Using cubic interpolation
    octave1DCubic(\x,\octave,\periode,\amplitude)=\amplitude*cubicInterpolation(sampleDelta(\x,\periode), sampleLeftLeft(\x,\periode,\octave), sampleLeft(\x,\periode,\octave), sampleRight(\x,\periode,\octave), sampleRightRight(\x,\periode,\octave));
    % Craters
    sqdistance_(\dx,\dy)=\dx*\dx+\dy*\dy;
    sqdistance(\x,\y,\cx,\cy)=sqdistance_(\x-\cx,\y-\cy);
    % 2D Perlin
    noise2D(\x,\y,\octave)=hash(\x,hash(\y,hash(\octave,\noiseseed)));
    sampleLeftAbove2D(\x,\y,\periode,\octave)=noise2D(floor(\x/\periode), floor(\y/\periode) + 1, \octave);
    sampleLeftBelow2D(\x,\y,\periode,\octave)=noise2D(floor(\x/\periode), floor(\y/\periode), \octave);
    sampleRightAbove2D(\x,\y,\periode,\octave)=noise2D(floor(\x/\periode)+1, floor(\y/\periode) + 1, \octave);
    sampleRightBelow2D(\x,\y,\periode,\octave)=noise2D(floor(\x/\periode)+1, floor(\y/\periode), \octave);
    octave2DCosine(\x,\y,\octave,\periode,\amplitude)=\amplitude*cosineInterpolation(sampleDelta(\y,\periode),
    cosineInterpolation(sampleDelta(\x,\periode), sampleLeftBelow2D(\x,\y,\periode,\octave), sampleRightBelow2D(\x,\y,\periode,\octave)),
    cosineInterpolation(sampleDelta(\x,\periode), sampleLeftAbove2D(\x,\y,\periode,\octave), sampleRightAbove2D(\x,\y,\periode,\octave))
    );
    perlin2DCosine_(\x,\y,\octave,\periode,\octaves,\persistance,\amplitude)=lazyifthenelse(\octave >= \octaves, 0, "octave2DCosine(\x,\y,\octave,\periode,\amplitude) + perlin2DCosine_(\x,\y,\octave+1,\periode*0.5,\octaves,\persistance,\amplitude*\persistance)");
    perlin2DCosine(\x,\y,\periode,\octaves,\persistance,\amplitude)=perlin2DCosine_(\x,\y,0,\periode,\octaves,\persistance,\amplitude);
  }
}
\shorthandon{;?:}

\subsection{Perlin noise}
\begin{frame}
  \frametitle{Perlin noise}
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}[
      scale=0.09,
      pcurve/.style={samples at={0,1,...,64}, smooth},
      mcurve/.style={pcurve, mark=ball, mark size=18},
      mgray/.style={mcurve,gray!50!white}]
      % Prendre de la place lorsqu'on n'affiche pas les courbes supérieures.
      \path (0,-5) -- (0,40);
      \only<1-14>{
        \path (-5,0) -- (70,0);
        \node[anchor=east] at (-2,0) {\hphantom{\small $1+2+3$}};
        \node[anchor=west] at (64+2,0) {\hphantom{\small $1+2+3$}};
      }
      
      % Lignes horizontales
      \only<1-14>{  \draw[->,gray] (0,0) -- (70,0); }
      \only<2-3,7-14>{ \draw[->,gray] (0,20) -- (70,20); }
      \only<3-4,7-14>{ \draw[->,gray] (0,30) -- (70,30); }

      % Amplitude
      \only<11>{  \draw[<->, thick, red] (-2,1) -- (-2,19); }
      % Octaves
      \only<12>{  \node[anchor=east, text=red] at (-2,10)   {1}; }
      \only<12>{  \node[anchor=east, text=red] at (-2,25)   {2}; }
      \only<12>{  \node[anchor=east, text=red] at (-2,32.5) {3}; }
      % Fréquence
      \only<13>{  \draw[<->, thick, red] (0,-2) -- (16,-2); }
      \only<13>{  \draw[dashed, red]     (0,-2) -- (0,{octave1DCosine(0,0,16,20)}); }
      \only<13>{  \draw[dashed, red]     (16,-2) -- (16,{octave1DCosine(16,0,16,20)}); }
      % Persistance
      \only<14>{  \draw[<->, dashed, red] (-2,1) -- (-2,19); }
      \only<14>{  \draw[<->, dashed, red] (-2,21) -- (-2,29); }
      \only<14>{  \draw[thick, red]   (-2,10) edge[->,bend left=70] node[left] {\small $\times 0.5$} (-2,25); }
      
      % Étiquette à gauche
      \only<4>{   \node[anchor=east] at (-2,{perlin1DCosine(0,16,2,0.5,20)}) {\small $1+2$}; }
      \only<5>{   \node[anchor=east] at (-2,{perlin1DCosine(0,16,3,0.5,20)}) {\small $1+2+3$}; }
      
      % Octave 0
      \only<1-3>{ \draw[mcurve, mark repeat=16] plot (\x,{octave1DCosine(\x,0,16,20)}); }
      \only<4>{   \draw[pcurve, gray]           plot (\x,{octave1DCosine(\x,0,16,20)}); }
      \only<5>{   \draw[pcurve, gray!50!white]  plot (\x,{octave1DCosine(\x,0,16,20)}); }
      \only<7>{   \draw[mgray,  mark repeat=16] plot (\x,{octave1DLinear(\x,0,16,20)}); }
      \only<8>{   \draw[mcurve, mark repeat=16] plot (\x,{octave1DLinear(\x,0,16,20)}); }
      \only<9>{   \draw[mcurve, mark repeat=16] plot (\x,{octave1DCubic(\x,0,16,20)}); }
      \only<10-14>{  \draw[mcurve, mark repeat=16] plot (\x,{octave1DCosine(\x,0,16,20)}); }
      
      % Octave 1
      \only<2-3>{ \draw[mcurve, mark repeat=8]  plot (\x,{octave1DCosine(\x,1,8,10) + 20}); }
      \only<7>{   \draw[mgray,  mark repeat=8]  plot (\x,{octave1DLinear(\x,1,8,10) + 20}); }
      \only<8>{   \draw[mcurve, mark repeat=8]  plot (\x,{octave1DLinear(\x,1,8,10) + 20}); }
      \only<9>{   \draw[mcurve, mark repeat=8]  plot (\x,{octave1DCubic(\x,1,8,10)  + 20}); }
      \only<10-14>{  \draw[mcurve, mark repeat=8]  plot (\x,{octave1DCosine(\x,1,8,10) + 20}); }
      
      % Octave 2
      \only<3-4>{ \draw[mcurve, mark repeat=4]  plot (\x,{octave1DCosine(\x,2,4,5)  + 30}); }
      \only<7>{   \draw[mgray,  mark repeat=4]  plot (\x,{octave1DLinear(\x,2,4,5)  + 30}); }
      \only<8>{   \draw[mcurve, mark repeat=4]  plot (\x,{octave1DLinear(\x,2,4,5)  + 30}); }
      \only<9>{   \draw[mcurve, mark repeat=4]  plot (\x,{octave1DCubic(\x,2,4,5)   + 30}); }
      \only<10-14>{\draw[mcurve, mark repeat=4] plot (\x,{octave1DCosine(\x,2,4,5)  + 30}); }
      
      % Octave 0+1
      \only<4>{   \draw[mcurve, mark repeat=8]  plot (\x,{perlin1DCosine(\x,16,2,0.5,20)}); }
      \only<5>{   \draw[pcurve, gray]           plot (\x,{perlin1DCosine(\x,16,2,0.5,20)}); }
      
      % Octave 0+1+2
      \only<5>{   \draw[mcurve, mark repeat=4]  plot (\x,{perlin1DCosine(\x,16,3,0.5,20)}); }
      \only<6>{   \draw[pcurve]                 plot (\x,{perlin1DCosine(\x,16,3,0.5,20)}); }
    \end{tikzpicture}
    % Hash de coordonnées
    \begin{tikzpicture}[
      node distance=0.5cm,
      every node/.style={rectangle,minimum size=6mm,rounded corners=3mm,very thick,draw=black!50}
      ]
      \only<15>{
        \path (0,-5*0.09) -- (0,40*0.09); % This and the 17.5*0.09 below are for vertical alignment with the other figure.
        \node[draw] (hash1) at (0,17.5*0.09) {hash};
        \node[draw,above left=of hash1, draw=blue!50] (x) {$x$};
        \node[draw,below left=of hash1] (noctave) {n\textdegree octave};
        \draw[->] (x) -- (hash1);
        \draw[->] (noctave) -- (hash1);
        \node[draw, right=of hash1] (hash2) {hash};
        \node[draw,below left=of hash2] (seed) {graine};
        \draw[->] (hash1) -- (hash2);
        \draw[->] (seed) -- (hash2);
        \node[right=of hash2, draw=green!50] (valeur) {$valeur$};
        \draw[->] (hash2) -- (valeur);
      }
    \end{tikzpicture}
    % \caption{Perlin noise}
  \end{figure}
  \begin{itemize}
  \item<1-> Superposition d'octaves de bruit ($\text{seed} = \noiseseed$).% TODO : choisir une bonne seed et virer ça.
  \item<7-> Interpolation\only<8->{ linéaire}\only<9->{, cubique}\only<10->{ ou cosinusoidale.}
  \item<11-> Amplitude\only<12->{, octaves}\only<13->{, fréquence}\only<14->{, persistance.}
  \item<15-> Hash de coordonnées
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Perlin noise (Variations)}
  \begin{itemize}
  \item<1-> Cavernes, nuages\only<2->{, textures, terrains : bruit $n$D et voxels.}
    \only<1>{
      \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=0.025]
          \xdef\twodperlinsize{128}
          \xdef\maxvtwodperlin{0}
          \xdef\minvtwodperlin{0}
          \def\maxradius{32}
          \def\ncircles{10}
          \foreach \y in {1,2,...,\twodperlinsize}{
            \message{Perlin 2D line \y/\twodperlinsize.}
            \foreach \x in {1,2,...,\twodperlinsize}{
              \pgfmathsetmacro{\v}{-perlin2DCosine(\x,\y,16,3,0.5,50}
              \setcache{vtwodperlin,\x,\y}{\v}
              \pgfmathparse{max(\maxvtwodperlin,\v)}
              \xdef\maxvtwodperlin{\pgfmathresult}
              \pgfmathparse{min(\minvtwodperlin,\v)}
              \xdef\minvtwodperlin{\pgfmathresult}
            }
          }
          \definecolor{gradientpoint0}{rgb}{0,0,1}
          \definecolor{gradientpoint1}{rgb}{0,0.3,1}
          \definecolor{gradientpoint2}{rgb}{0.3,0.3,1}
          \definecolor{gradientpoint3}{rgb}{1,1,1}
          \def\positions{{0,0.1,0.9,1}}
          \foreach \y in {1,2,...,\twodperlinsize}{
            \message{Gradient line \y/\twodperlinsize...}
            \foreach \x in {1,2,...,\twodperlinsize}{
              \pgfmathsetmacro{\v}{(\getcache{vtwodperlin,\x,\y}-\minvtwodperlin)/max(1,\maxvtwodperlin-\minvtwodperlin)}
              \pgfmathsetmacro{\v}{max(0,min(1,\v))}
              \foreach \pointb in {1,...,3}{
                \pgfmathsetmacro{\posb}{\positions[\pointb]}
                \pgfmathparse{\v <= \posb}
                \ifnum 1=\pgfmathresult
                \setintmacro{\pointa}{\pointb-1}
                \pgfmathsetmacro{\posa}{\positions[\pointa]}
                \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                \xdef\colora{gradientpoint\pointa}
                \xdef\colorb{gradientpoint\pointb}
                \xdef\mix{\mix}
                \breakforeach
                \fi
              }
              \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
            }
          }
        \end{tikzpicture}
      \end{figure}
    }
    \only<2>{
      \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=0.025]
          \definecolor{gradientpoint0}{rgb}{0,0,0.5}
          \definecolor{gradientpoint1}{rgb}{0.2,0.2,1}
          \definecolor{gradientpoint2}{rgb}{0.9,0.6,0.1}
          \definecolor{gradientpoint3}{rgb}{0.1,0.6,0.2}
          \definecolor{gradientpoint4}{rgb}{0.6,0.3,0.05}
          \definecolor{gradientpoint5}{rgb}{1,1,1}
          \def\positions{{0,0.3,0.4,0.88,0.94,1}}
          \foreach \y in {1,2,...,\twodperlinsize}{
            \message{Gradient line \y/\twodperlinsize...}
            \foreach \x in {1,2,...,\twodperlinsize}{
              \pgfmathsetmacro{\v}{(\getcache{vtwodperlin,\x,\y}-\minvtwodperlin)/max(1,\maxvtwodperlin-\minvtwodperlin)}
              \pgfmathsetmacro{\v}{max(0,min(1,\v))}
              \foreach \pointb in {1,...,5}{
                \pgfmathsetmacro{\posb}{\positions[\pointb]}
                \pgfmathparse{\v <= \posb}
                \ifnum 1=\pgfmathresult
                \setintmacro{\pointa}{\pointb-1}
                \pgfmathsetmacro{\posa}{\positions[\pointa]}
                \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                \xdef\colora{gradientpoint\pointa}
                \xdef\colorb{gradientpoint\pointb}
                \xdef\mix{\mix}
                \breakforeach
                \fi
              }
              \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
            }
          }
        \end{tikzpicture}
      \end{figure}
    }
  \item<3-> Ridged Perlin Noise.
    \only<3>{
      \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=0.025]
          \definecolor{gradientpoint0}{rgb}{0,0,0.5}
          \definecolor{gradientpoint1}{rgb}{0.2,0.2,1}
          \definecolor{gradientpoint2}{rgb}{0.9,0.6,0.1}
          \definecolor{gradientpoint3}{rgb}{0.1,0.6,0.2}
          \definecolor{gradientpoint4}{rgb}{0.6,0.3,0.05}
          \definecolor{gradientpoint5}{rgb}{1,1,1}
          \def\positions{{0,0.3,0.4,0.88,0.94,1}}
          \foreach \y in {1,2,...,\twodperlinsize}{
            \message{Gradient line \y/\twodperlinsize...}
            \foreach \x in {1,2,...,\twodperlinsize}{
              \pgfmathsetmacro{\v}{(\getcache{vtwodperlin,\x,\y}-\minvtwodperlin)/max(1,\maxvtwodperlin-\minvtwodperlin)}
              \pgfmathsetmacro{\v}{max(0,min(1,\v))}
              \pgfmathsetmacro{\v}{abs(\v-0.5)*2}
              \foreach \pointb in {1,...,5}{
                \pgfmathsetmacro{\posb}{\positions[\pointb]}
                \pgfmathparse{\v <= \posb}
                \ifnum 1=\pgfmathresult
                \setintmacro{\pointa}{\pointb-1}
                \pgfmathsetmacro{\posa}{\positions[\pointa]}
                \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                \xdef\colora{gradientpoint\pointa}
                \xdef\colorb{gradientpoint\pointb}
                \xdef\mix{\mix}
                \breakforeach
                \fi
              }
              \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
            }
          }
        \end{tikzpicture}
      \end{figure}
    }
  \item<4-> Midpoint displacement.
  \item<5-> Simplex noise : généralisation des triangles équilatéraux à $n$ dimensions, interpolation par rapport aux coins. $d^2$ au lieu de $2^d$.
  \item<6-> Bruit répétable 1D : points sur un cercle dans un espace 2D. Généralisation à $n$ dimensions : hypercercle $n$D dans un espace $2n$D.
    {\tiny\url{http://www.gamedev.net/blog/33/entry-2138456-seamless-noise/}}
  \end{itemize}
\end{frame}

\subsection{Craters et Hills Algorithm}
\begin{frame}
  \frametitle{Craters et Hills Algorithm}
  \begin{itemize}
  \item<1-> Craters
    \begin{itemize}
    \item<1-> Soustraire des cercles au terrain ({\small $z = z - f(\text{distance au centre})$})
    \item<2-> Sur un terrain nu
      \only<2>{
        \begin{figure}[h]
          \centering
          \begin{tikzpicture}[scale=0.025]
            \xdef\craterssize{128}
            \xdef\maxvcraters{0}
            \xdef\minvcraters{0}
            \def\maxradius{32}
            \def\ncircles{100}
            \foreach \y in {1,2,...,\craterssize}{
              \foreach \x in {1,2,...,\craterssize}{
                \setcache{vcraters,\x,\y}{0}
              }
            }
            \foreach \c in {1,...,\ncircles}{
              \setintmacro{\circlex}{noise1D(\c,0)*\craterssize}
              \setintmacro{\circley}{noise1D(\c,1)*\craterssize}
              \setintmacro{\circler}{noise1D(\c,2)*\maxradius}
              \message{Circle number \c/\ncircles, center (\circlex, \circley), radius \circler}
              \foreach \dy in {-\circler,...,\circler}{
                \setintmacro{\y}{\circley+\dy}
                \pgfmathparse{(\y > 0) && (\y <= \craterssize)}
                \ifnum 1=\pgfmathresult
                \foreach \dx in {-\circler,...,\circler}{
                  \setintmacro{\x}{\circlex+\dx}
                  \pgfmathparse{(\x > 0) && (\x <= \craterssize)}
                  \ifnum 1=\pgfmathresult
                  \xdef\oldv{\getcache{vcraters,\x,\y}}
                  \pgfmathsetmacro{\v}{\oldv - max(0,\circler - ((\dx*\dx + \dy*\dy)/\circler))}
                  \setcache{vcraters,\x,\y}{\v}
                  \pgfmathparse{max(\maxvcraters,\v)}
                  \xdef\maxvcraters{\pgfmathresult}
                  \pgfmathparse{min(\minvcraters,\v)}
                  \xdef\minvcraters{\pgfmathresult}
                  \fi
                }
                \fi
              }
            }
            \definecolor{gradientpoint0}{rgb}{0,0,0.5}
            \definecolor{gradientpoint1}{rgb}{0.2,0.2,1}
            \definecolor{gradientpoint2}{rgb}{0.9,0.6,0.1}
            \definecolor{gradientpoint3}{rgb}{0.1,0.6,0.2}
            \definecolor{gradientpoint4}{rgb}{0.6,0.3,0.05}
            \definecolor{gradientpoint5}{rgb}{1,1,1}
            \def\positions{{0,0.3,0.4,0.88,0.94,1}}
            \foreach \y in {1,2,...,\craterssize}{
              \message{Gradient line \y/\craterssize...}
              \foreach \x in {1,2,...,\craterssize}{
                \pgfmathsetmacro{\v}{(\getcache{vcraters,\x,\y}-\minvcraters)/max(1,\maxvcraters-\minvcraters)}
                \pgfmathsetmacro{\v}{max(0,min(1,\v))}
                \foreach \pointb in {1,...,5}{
                  \pgfmathsetmacro{\posb}{\positions[\pointb]}
                  \pgfmathparse{\v < \posb}
                  \ifnum 1=\pgfmathresult
                  \setintmacro{\pointa}{\pointb-1}
                  \pgfmathsetmacro{\posa}{\positions[\pointa]}
                  \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                  \xdef\colora{gradientpoint\pointa}
                  \xdef\colorb{gradientpoint\pointb}
                  \xdef\mix{\mix}
                  \breakforeach
                  \fi
                }
                \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
              }
            }
          \end{tikzpicture}
        \end{figure}
      }
    \item<3-> Sur un terrain existant
        \only<3>{
        \begin{figure}[h]
          \centering
          \begin{tikzpicture}[scale=0.025]
            \xdef\cratersperlinsize{\twodperlinsize}
            \xdef\maxvcratersperlin{\maxvtwodperlin}
            \xdef\minvcratersperlin{\minvtwodperlin}
            \def\maxradius{32}
            \def\ncircles{20}
            \foreach \y in {1,2,...,\cratersperlinsize}{
              \foreach \x in {1,2,...,\cratersperlinsize}{
                \setcache{vcratersperlin,\x,\y}{\getcache{vtwodperlin,\x,\y}}
              }
            }
            \foreach \c in {1,...,\ncircles}{
              \setintmacro{\circlex}{noise1D(\c,0)*\cratersperlinsize}
              \setintmacro{\circley}{noise1D(\c,1)*\cratersperlinsize}
              \setintmacro{\circler}{noise1D(\c,2)*\maxradius}
              \message{Circle number \c/\ncircles, center (\circlex, \circley), radius \circler}
              \foreach \dy in {-\circler,...,\circler}{
                \setintmacro{\y}{\circley+\dy}
                \pgfmathparse{(\y > 0) && (\y <= \cratersperlinsize)}
                \ifnum 1=\pgfmathresult
                \foreach \dx in {-\circler,...,\circler}{
                  \setintmacro{\x}{\circlex+\dx}
                  \pgfmathparse{(\x > 0) && (\x <= \cratersperlinsize)}
                  \ifnum 1=\pgfmathresult
                  \xdef\oldv{\getcache{vcratersperlin,\x,\y}}
                  \pgfmathparse{\oldv - max(0,\circler - ((\dx*\dx + \dy*\dy)/\circler))}
                  \setcache{vcratersperlin,\x,\y}{\pgfmathresult}
                  \pgfmathparse{max(\maxvcratersperlin,\pgfmathresult)}
                  \xdef\maxvcratersperlin{\pgfmathresult}
                  \pgfmathparse{min(\minvcratersperlin,\pgfmathresult)}
                  \xdef\minvcratersperlin{\pgfmathresult}
                  \fi
                }
                \fi
              }
            }
            \definecolor{gradientpoint0}{rgb}{0,0,0.5}
            \definecolor{gradientpoint1}{rgb}{0.2,0.2,1}
            \definecolor{gradientpoint2}{rgb}{0.9,0.6,0.1}
            \definecolor{gradientpoint3}{rgb}{0.1,0.6,0.2}
            \definecolor{gradientpoint4}{rgb}{0.6,0.3,0.05}
            \definecolor{gradientpoint5}{rgb}{1,1,1}
            \def\positions{{0,0.3,0.4,0.88,0.94,1}}
            \foreach \y in {1,2,...,\cratersperlinsize}{
              \message{Gradient line \y/\cratersperlinsize...}
              \foreach \x in {1,2,...,\cratersperlinsize}{
                \pgfmathsetmacro{\v}{(\getcache{vcratersperlin,\x,\y}-\minvcratersperlin)/max(1,\maxvcratersperlin-\minvcratersperlin)}
                \pgfmathsetmacro{\v}{max(0,min(1,\v))}
                \foreach \pointb in {1,...,5}{
                  \pgfmathsetmacro{\posb}{\positions[\pointb]}
                  \pgfmathparse{\v <= \posb}
                  \ifnum 1=\pgfmathresult
                  \setintmacro{\pointa}{\pointb-1}
                  \pgfmathsetmacro{\posa}{\positions[\pointa]}
                  \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                  \xdef\colora{gradientpoint\pointa}
                  \xdef\colorb{gradientpoint\pointb}
                  \xdef\mix{\mix}
                  \breakforeach
                  \fi
                }
                \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
              }
            }
          \end{tikzpicture}
        \end{figure}
        }
    \end{itemize}
  \item<4-> Hills Algorithm~: ajouter des cercles
      \only<4>{
        \begin{figure}[h]
          \centering
          \begin{tikzpicture}[scale=0.025]
            \definecolor{gradientpoint0}{rgb}{0,0,0.5}
            \definecolor{gradientpoint1}{rgb}{0.2,0.2,1}
            \definecolor{gradientpoint2}{rgb}{0.9,0.6,0.1}
            \definecolor{gradientpoint3}{rgb}{0.1,0.6,0.2}
            \definecolor{gradientpoint4}{rgb}{0.6,0.3,0.05}
            \definecolor{gradientpoint5}{rgb}{1,1,1}
            \def\positions{{0,0.3,0.4,0.88,0.94,1}}
            \foreach \y in {1,2,...,\craterssize}{
              \message{Gradient line \y/\craterssize...}
              \foreach \x in {1,2,...,\craterssize}{
                \pgfmathsetmacro{\v}{(\getcache{vcraters,\x,\y}-\minvcraters)/max(1,\maxvcraters-\minvcraters)}
                \pgfmathsetmacro{\v}{max(0,min(1,\v))}
                \pgfmathsetmacro{\v}{1-\v}
                \foreach \pointb in {1,...,5}{
                  \pgfmathsetmacro{\posb}{\positions[\pointb]}
                  \pgfmathparse{\v < \posb}
                  \ifnum 1=\pgfmathresult
                  \setintmacro{\pointa}{\pointb-1}
                  \pgfmathsetmacro{\posa}{\positions[\pointa]}
                  \pgfmathsetmacro{\mix}{100 - 100 * (\v-\posa) / (\posb-\posa)}
                  \xdef\colora{gradientpoint\pointa}
                  \xdef\colorb{gradientpoint\pointb}
                  \xdef\mix{\mix}
                  \breakforeach
                  \fi
                }
                \path[fill=\colora!\mix!\colorb] (\x,\y) rectangle ++(1.5,1.5);
              }
            }
          \end{tikzpicture}
        \end{figure}
      }
  \item<5-> Stockage des cercles dans un arbre (BSP, Quadtree, LOD, \dots{}).
  \end{itemize}
\end{frame}

\subsection{Érosion}

\begin{frame}
  \frametitle{Érosion}
  \begin{itemize}
  \item Déplacement de sédiments.
  \item Taux en fonction de la pente, dureté de la roche, végétation.
  \item Carte de circulation des eaux.
  \item Pas temps-réel.
  \item Approximation : modification de la distribution des hauteurs.
    % TODO : schéma
    \begin{figure}[h]
      \centering
      \begin{tikzpicture}
        % Un dégradé vertical indiquant l'élévation de départ
        % Fonction f(x) = x
        % 2e dégradé indiquant le résultat.
        % Même chose avec une autre fonction.
      \end{tikzpicture}
    \end{figure}
  \end{itemize}
\end{frame}

\subsection{Autres}
\begin{frame}
  \frametitle{Autres méthodes}
  \begin{itemize}
  \item Chaînage d'algorithmes de bruit
    \begin{itemize}
    \item Ajout de couleurs, climats, végétation, relief\dots{}
    \item Altération du comportement d'un algo.
    \item {\tiny\url{http://www.gamedev.net/blog/33/entry-2249260-procedural-islands-redux/}}
    \end{itemize}
  \item Cartes polygonales. {\tiny\url{http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/}}
    % TODO : images
    % - découpage du plan en polygones
    % - positionnement de la mer et des lacs
    % - hauteur fonction de la distance à la mer.
    % - tracé de rivières en descendant le long des segments des polygones.
    % - climats et biotopes en fonction de l'élévation et de la distance à l'humidité.
    % - bruitage supplémentaire.
  \item Intégration de formes dans le terrain.
  \end{itemize}
\end{frame}

\subsection{Rivières}

\begin{frame}
  \frametitle{Rivières}
  \begin{itemize}
  \item Pathfinding {\tiny\url{http://www.umbrarumregnum.net/articles/creating-rivers}}
	% Image
  \item Affinage du tracé en fonction du LOD.
	% Schéma sur un ou deux niveaux d'affinage.
  \item Tracé arbitraire.
  \item Intégration dans le terrain.
  \end{itemize}
\end{frame}
% Si on utilise une méthode de coût qui favorise de passer par un petit
% bout de bruit plutôt que de le contourner, mais favorise le
% contournement pour une grosse accumulation de bruit, on pourra même
% simuler l'érosion qui efface les méandres trop petits.

\subsection{Démonstration}
\begin{frame}
  \frametitle{Démonstration}
  \begin{center}
  {\Huge World machine}
  
  \vspace{1em}
  \url{http://www.world-machine.com/}
  \end{center}
\end{frame}

\section{Rendu}

\subsection{Isosurfaces}
\begin{frame}
  \frametitle{Isosurfaces}
  \begin{itemize}
    \item Metaballs % TODO : écran de veille / screenshot.
    \item Surface 2D d'un bruit 3D.
    \item Simplification de nuages.
    \item Surface de l'eau.
  \end{itemize}
\end{frame}

\subsection{Ray casting}

\begin{frame}
  \frametitle{Ray casting}
  \begin{itemize}
  \item Très simple, très petit code.
	% TODO : Schéma d'explication
  \item Sampling
  \item Très lent
  \item Démonstration
  \item Monte Carlo
  \end{itemize}
\end{frame}

\section[LOD]{Niveau de détail}

\subsection{ROAM}
\begin{frame}
  \frametitle{ROAM}
  \begin{itemize}
  \item Triangle bintree.
	% TODO : Figure : triangle avec 2 fils.
  \item Split et merge. CLOD.
	% TODO : Figure : split forcé, merge d'un losange.
  \item Défaut maximal visible à l'écran.
	% TODO : Figure : Dessin projection pavé triangle erreur à l'écran.
  \item Split queue et Merge queue.
	% TODO : queues l'une au-dessus de l'autre, montrer qu'on va +- les priorités pour éviter le chevauchement.
  \item Frustum culling : utilisation de drapaux.
  \item Améliorations~:
    \begin{itemize}
    \item Triangle stripping.
    \item Geomorphing.
    \item Calcul différé des priorités dans les queues.
    \item Temps réel.
    \end{itemize}
  \item $O(\text{Nb triangles mis à jour})$
  \end{itemize}
\end{frame}

\subsection{Geometry clipmaps}
\begin{frame}
  \frametitle{Geometry clipmaps}
  \begin{itemize}
  \item Carrés concentriques avec des LOD différents.
  \item Comme le mipmapping de textures.
  \item Utilisation forte du GPU.
  \item Displacement shader.
  \item Remplissage à la jointure des LOD.
  \end{itemize}
\end{frame}

\subsection{Notre algo}
\begin{frame}
  \frametitle{Notre algorithme}
  \begin{itemize}
  \item Quadtree de carrés.
	% TODO : figure
	% TODO : figure trous dans le mesh
  \item Triangle fans.
  \item LOD en fonction de la distance.
  \item Mise à jour de quelques branches seulement.
  \item Temps réel.
  \item $O(\text{Nb triangles mis à jour})$
  \end{itemize}
\end{frame}

\subsection{Streaming de scène}
\begin{frame}
  \frametitle{Streaming de scène}
  \begin{itemize}
  \item Modèle client/serveur.
  \item Tiles avec LOD maximal.
  \item Qualité progressive des tiles.
  \item Geometry clipmaps.
  \item \texttt{/usr/lib/xscreensaver/crackberg}
  \end{itemize}
\end{frame}

% \section{Conclusion}

% \begin{frame}
%   \frametitle{Conclusion}
% \end{frame}

\begin{frame}
  \frametitle{Sources}
% Génération
% * [Différents algos]() : Ridged Perlin Noise, Hills Algorithm, Craters, Erosion.
% * [Plein d'algos](http://planetgenesis.sourceforge.net/docs15/noise/noise.html#tileworley) dont plusieurs basés sur une sorte de voronoi donc à priori trop lents.
% * Affichage avec Ogre : [forum](http://www.ogre3d.org/forums/viewtopic.php?f=5&t=67177&p=442222), [doc](http://www.ogre3d.org/docs/api/html/classOgre_1_1BillboardSet.html)
  \begin{itemize}
  \item Perlin noise {\tiny \url{http://freespace.virgin.net/hugo.elias/models/m_perlin.htm}}
  \item http://www.gamasutra.com
  \item http://vterrain.org
  % \item Mojoworld generator (mojoworld.org)
  \item http://world-machine.com
  \item Algorithmes de bruit {\tiny \url{http://www.sluniverse.com/php/vb/project-development/34994-automatically-generated-terrain-map.html}}
  \item Composition d'algorithmes de bruit {\tiny \url{http://www.gamedev.net/blog/33/entry-2249260-procedural-islands-redux/}}
  \item Création de cartes polygonales {\tiny \url{http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/}}
  \item Pathfinding pour créer des rivières {\tiny \url{http://www.umbrarumregnum.net/articles/creating-rivers}}
  \end{itemize}
\end{frame}

\end{document}
